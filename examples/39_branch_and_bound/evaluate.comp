#version 450
#extension GL_EXT_nonuniform_qualifier : require

struct Item { float val; float weight; };
struct Node { float val; float weight; uint depth; uint parent; uint status; float x_pos; uint p1, p2; };

layout(set = 0, binding = 0) buffer AllInOne { uint data[]; } all_bufs[];

layout(push_constant) uniform PushConstants {
    float dt; float time; uint max_nodes; uint num_items; float capacity; uint start_idx; uint num_to_process; uint mode;
} pc;

layout (local_size_x = 64) in;

float get_upper_bound(float current_v, float current_w, uint depth) {
    float remaining_w = pc.capacity - current_w;
    float bound = current_v;
    for (uint i = depth; i < pc.num_items; i++) {
        uint b = i * 2;
        float iv = uintBitsToFloat(all_bufs[0].data[b]);
        float iw = uintBitsToFloat(all_bufs[0].data[b+1]);
        if (remaining_w >= iw) { remaining_w -= iw; bound += iv; }
        else { bound += iv * (remaining_w / iw); break; }
    }
    return bound;
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= pc.num_to_process) return;
    uint cur = pc.start_idx + gid;
    if (cur >= pc.max_nodes || all_bufs[1].data[cur * 8 + 4] != 0) return;

    uint b = cur * 8;
    float n_val = uintBitsToFloat(all_bufs[1].data[b+0]);
    float n_weight = uintBitsToFloat(all_bufs[1].data[b+1]);
    uint  n_depth = all_bufs[1].data[b+2];
    float n_x = uintBitsToFloat(all_bufs[1].data[b+5]);

    float current_best = uintBitsToFloat(all_bufs[2].data[1]);
    if (get_upper_bound(n_val, n_weight, n_depth) <= current_best) {
        all_bufs[1].data[cur * 8 + 4] = 1; // PRUNE
        return;
    }

    if (n_depth < pc.num_items) {
        uint b_item = n_depth * 2;
        float i_val = uintBitsToFloat(all_bufs[0].data[b_item]);
        float i_weight = uintBitsToFloat(all_bufs[0].data[b_item+1]);

        // Very slow spread decay to keep tree wide
        float spread = 0.3 * pow(0.96, n_depth);

        // Branch 1 (Right)
        if (n_weight + i_weight <= pc.capacity) {
            uint cid = atomicAdd(all_bufs[2].data[0], 1);
            if (cid < pc.max_nodes) {
                uint cb = cid * 8;
                all_bufs[1].data[cb+0] = floatBitsToUint(n_val + i_val);
                all_bufs[1].data[cb+1] = floatBitsToUint(n_weight + i_weight);
                all_bufs[1].data[cb+2] = n_depth + 1;
                all_bufs[1].data[cb+3] = cur;
                all_bufs[1].data[cb+4] = 0;
                all_bufs[1].data[cb+5] = floatBitsToUint(n_x + spread);
                atomicMax(all_bufs[2].data[1], all_bufs[1].data[cb+0]);
            }
        }
        // Branch 2 (Left)
        uint cid = atomicAdd(all_bufs[2].data[0], 1);
        if (cid < pc.max_nodes) {
            uint cb = cid * 8;
            all_bufs[1].data[cb+0] = floatBitsToUint(n_val);
            all_bufs[1].data[cb+1] = floatBitsToUint(n_weight);
            all_bufs[1].data[cb+2] = n_depth + 1;
            all_bufs[1].data[cb+3] = cur;
            all_bufs[1].data[cb+4] = 0;
            all_bufs[1].data[cb+5] = floatBitsToUint(n_x - spread);
        }
        all_bufs[1].data[cur * 8 + 4] = 3; // PROCESSED
    } else {
        all_bufs[1].data[cur * 8 + 4] = 2; // LEAF
    }
}
