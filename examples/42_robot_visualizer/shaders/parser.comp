#version 450
#extension GL_EXT_nonuniform_qualifier : enable
layout(local_size_x = 256) in;

layout(set = 0, binding = 0) buffer Data { uint u32[]; } all_buffers[];

struct Instruction {
    uint src_byte_offset;
    uint dst_slot;
    uint type_id;
    uint padding;
};

layout(push_constant) uniform PC {
    uint in_buf_idx;
    uint in_offset_bytes; // Now in BYTES
    uint out_buf_idx;
    uint count;
    uint mode; 
    uint instr_buf_idx; 
    uint in_stride_bytes; // Now in BYTES
    uint in_pos_offset_bytes; // Now in BYTES
} pc;

float readFloatUnaligned(uint byte_off, uint buf_idx) {
    uint u32_idx = byte_off / 4;
    uint shift = (byte_off % 4) * 8;
    uint v0 = all_buffers[nonuniformEXT(buf_idx)].u32[u32_idx];
    if (shift == 0) return uintBitsToFloat(v0);
    uint v1 = all_buffers[nonuniformEXT(buf_idx)].u32[u32_idx + 1];
    uint val = (v0 >> shift) | (v1 << (32 - shift));
    return uintBitsToFloat(val);
}

void main() {
    if (pc.mode == 0) {
        uint idx = gl_GlobalInvocationID.x;
        if (idx >= pc.count) return;
        
        uint base = pc.in_offset_bytes + (idx * pc.in_stride_bytes) + pc.in_pos_offset_bytes;
        float x = readFloatUnaligned(base + 0, pc.in_buf_idx);
        float y = readFloatUnaligned(base + 4, pc.in_buf_idx);
        float z = readFloatUnaligned(base + 8, pc.in_buf_idx);

        uint out_base = idx * 4; 
        all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[out_base + 0] = floatBitsToUint(x);
        all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[out_base + 1] = floatBitsToUint(y);
        all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[out_base + 2] = floatBitsToUint(z);
        all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[out_base + 3] = floatBitsToUint(1.0);
    } else {
        // UNIVERSAL TELEMETRY MODE (Fields)
        // Uses a sequential VM, so we only use thread 0
        if (gl_GlobalInvocationID.x != 0) return;

        uint read_offset = pc.in_offset_bytes + 4; // Absolute Byte offset + 4 bytes CDR header

        for (uint i = 0; i < pc.count; ++i) {
            uint instr_base = i * 4;
            uint op       = all_buffers[nonuniformEXT(pc.instr_buf_idx)].u32[instr_base + 0];
            uint dst_slot = all_buffers[nonuniformEXT(pc.instr_buf_idx)].u32[instr_base + 1];
            uint type_id  = all_buffers[nonuniformEXT(pc.instr_buf_idx)].u32[instr_base + 2];
            uint sz       = all_buffers[nonuniformEXT(pc.instr_buf_idx)].u32[instr_base + 3];

            if (op == 0) { // OP_STATIC
                uint align_req = (sz < 8) ? sz : 8;
                if (sz == 0) align_req = 1; // Prevent div by zero, though sz=0 shouldn't happen for OP_STATIC
                read_offset = (read_offset + align_req - 1) & ~(align_req - 1);
                
                uint u32_idx = read_offset / 4;
                if (type_id >= 3 && type_id <= 5) { // 64-bit
                    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 0] = all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[u32_idx + 0];
                    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 1] = all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[u32_idx + 1];
                } else if (type_id >= 6 && type_id <= 7) { // 8-bit
                    uint word = all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[u32_idx];
                    uint shift = (read_offset % 4) * 8;
                    uint val = (word >> shift) & 0xFF;
                    if (type_id == 6 && (val & 0x80) != 0) val |= 0xFFFFFF00; // Sign extend int8
                    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 0] = val;
                    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 1] = 0;
                } else if (type_id >= 8 && type_id <= 9) { // 16-bit
                    uint word = all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[u32_idx];
                    uint shift = (read_offset % 4) * 8;
                    uint val = (word >> shift) & 0xFFFF;
                    if (type_id == 8 && (val & 0x8000) != 0) val |= 0xFFFF0000; // Sign extend int16
                    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 0] = val;
                    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 1] = 0;
                } else { // 32-bit
                    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 0] = all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[u32_idx];
                    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 1] = 0;
                }
                read_offset += sz;
            } else if (op == 1) { // OP_STRING
                read_offset = (read_offset + 3) & ~3; // Align string length (4 bytes)
                uint len = all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[read_offset / 4];
                all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 0] = len; // Output length
                all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 1] = 0;
                read_offset += 4 + len;
            } else if (op == 2) { // OP_DYN_ARRAY
                read_offset = (read_offset + 3) & ~3; // Align array length (4 bytes)
                uint len = all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[read_offset / 4];
                all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 0] = len; // Output count
                all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[dst_slot * 2 + 1] = 0;

                uint align_req = (sz < 8) ? sz : 8;
                if (sz == 0) align_req = 1;
                uint payload_start = read_offset + 4;
                payload_start = (payload_start + align_req - 1) & ~(align_req - 1);

                read_offset = payload_start + (len * sz);
            }
        }
    }
}
