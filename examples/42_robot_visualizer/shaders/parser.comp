#version 450
#extension GL_EXT_nonuniform_qualifier : enable
layout(local_size_x = 256) in;

layout(set = 0, binding = 0) buffer Data { uint u32[]; } all_buffers[];

layout(push_constant) uniform PC {
    uint in_buf_idx;
    uint in_offset_u32;
    uint out_buf_idx;
    uint count;
    uint in_stride_u32;
    uint in_pos_offset_u32;
} pc;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= pc.count) return;

    // Use dynamic stride and offset to find the point data
    // Stride is in uint32 units (4 bytes)
    uint base = pc.in_offset_u32 + (idx * pc.in_stride_u32) + pc.in_pos_offset_u32;
    
    float x = uintBitsToFloat(all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[base + 0]);
    float y = uintBitsToFloat(all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[base + 1]);
    float z = uintBitsToFloat(all_buffers[nonuniformEXT(pc.in_buf_idx)].u32[base + 2]);

    // Write to output buffer as vec4 (x, y, z, 1.0)
    uint out_base = idx * 4; 
    
    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[out_base + 0] = floatBitsToUint(x);
    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[out_base + 1] = floatBitsToUint(y);
    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[out_base + 2] = floatBitsToUint(z);
    all_buffers[nonuniformEXT(pc.out_buf_idx)].u32[out_base + 3] = floatBitsToUint(1.0);
}
