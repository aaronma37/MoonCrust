#version 450
#extension GL_EXT_nonuniform_qualifier : require

struct Particle {
    vec3 pos;
    float p1;
    vec3 vel;
    float p2;
};

struct AttractorData {
    float time;
    float mouse_x;
    float mouse_y;
    uint  mouse_down;
};

layout(set = 0, binding = 0) buffer AllBuffers {
    float data[];
} raw_buffers[];

layout(set = 0, binding = 0) buffer ParticleBuffer {
    Particle particles[];
} particle_buffers[];

layout(push_constant) uniform PushConstants {
    float dt;
    uint  buf_id;
    uint  attr_id;
    uint  tex_id;
} pc;

layout (local_size_x = 256) in;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= 1024 * 1024) return;

    uint bid = pc.buf_id;
    uint aid = pc.attr_id;
    
    vec3 pos = particle_buffers[bid].particles[idx].pos;
    vec3 vel = particle_buffers[bid].particles[idx].vel;

    // Attractor Data (Using raw buffer for the single struct)
    float time = raw_buffers[aid].data[0];
    float mx   = raw_buffers[aid].data[1];
    float my   = raw_buffers[aid].data[2];
    uint  mdown = floatBitsToUint(raw_buffers[aid].data[3]);

    vec3 target;
    if (mdown == 1) {
        target = vec3(mx, my, 0.0);
    } else {
        target.x = cos(time * 1.5) * 0.8;
        target.y = sin(time * 3.0) * 0.4;
        target.z = sin(time * 2.1) * 0.6;
    }

    vec3 dir = target - pos;
    float dist = length(dir);
    float distSq = dist * dist + 0.1; 
    
    if (dist > 0.0001) {
        float strength = (mdown == 1) ? 3.5 : 1.8;
        vec3 accel = (dir / dist) * (strength / distSq);
        vel += accel * pc.dt;
    }

    // Framerate-independent damping
    vel *= exp(-0.9 * pc.dt);
    pos += vel * pc.dt;

    // Save back
    particle_buffers[bid].particles[idx].pos = pos;
    particle_buffers[bid].particles[idx].vel = vel;
}
