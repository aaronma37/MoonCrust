#version 450
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 256) in;

layout(set = 0, binding = 0) buffer AllBuffers {
    uint data[];
} all_buffers[];

layout(push_constant) uniform PushConstants {
    uint samples;
    uint horizon;
    uint iter;
    uint pad0;
    float dt;
    float noise_yaw;
    float noise_pitch;
    float speed;
    float goal_x, goal_y, goal_z, goal_r;
    float obs1_x, obs1_y, obs1_z, obs1_r;
    float obs2_x, obs2_y, obs2_z, obs2_r;
    float obs3_x, obs3_y, obs3_z, obs3_r;
    float obs4_x, obs4_y, obs4_z, obs4_r;
    float obs5_x, obs5_y, obs5_z, obs5_r;
    float obs6_x, obs6_y, obs6_z, obs6_r;
    float obs7_x, obs7_y, obs7_z, obs7_r;
    float obs8_x, obs8_y, obs8_z, obs8_r;
} pc;

uint lcg(inout uint s) {
    s = s * 1664525u + 1013904223u;
    return s;
}

float frand(inout uint s) {
    uint v = lcg(s);
    return float(v & 0x00FFFFFFu) / float(0x01000000u);
}

float fsigned(inout uint s) {
    return frand(s) * 2.0 - 1.0;
}

float wrap_angle(float a) {
    return atan(sin(a), cos(a));
}

vec2 hoop_cost_reward(vec3 p, vec3 dir, vec4 h, vec3 n) {
    if (h.w <= 0.0) return vec2(0.0);
    vec3 d = p - h.xyz;
    float plane = dot(d, n);
    float radial = length(d - n * plane);
    float tube = 0.30;
    float plane_band = 0.55;
    float hole_r = max(0.35, h.w - tube - 0.12);

    float pen = 0.0;
    if (abs(plane) < plane_band) {
        float rim = abs(radial - h.w);
        float hit = max(0.0, tube - rim);
        pen += hit * hit * 260.0;
    }

    float through = max(0.0, 1.0 - abs(plane) / plane_band) * max(0.0, 1.0 - radial / hole_r);
    float align = max(0.0, dot(dir, n));
    float reward = through * (7.0 + 2.0 * align);
    return vec2(pen, reward);
}

float plane_patch_pen(vec3 p, vec4 pl) {
    if (pl.w <= 0.0) return 0.0;
    float hy = 1.2;
    float hz = 2.0;
    float px = abs(p.x - pl.x);
    float py = abs(p.y - pl.y);
    float pz = abs(p.z - pl.z);
    if (py > hy || pz > hz) return 0.0;
    float t = max(0.0, pl.w - px);
    return t * t * 900.0;
}

bool plane_cross_hit(vec3 prev_p, vec3 p, vec4 pl) {
    if (pl.w <= 0.0) return false;
    float hy = 1.2;
    float hz = 2.0;
    float a = prev_p.x - pl.x;
    float b = p.x - pl.x;
    if (a * b > 0.0) return false;
    float denom = abs(a) + abs(b) + 1e-6;
    float t = abs(a) / denom;
    float y = prev_p.y + (p.y - prev_p.y) * t;
    float z = prev_p.z + (p.z - prev_p.z) * t;
    if (abs(y - pl.y) > hy || abs(z - pl.z) > hz) return false;
    return true;
}

void main() {
    uint sid = gl_GlobalInvocationID.x;
    if (sid >= pc.samples) return;

    uint a_base = 0u;
    vec3 pos = vec3(
        uintBitsToFloat(all_buffers[4].data[a_base + 0]),
        uintBitsToFloat(all_buffers[4].data[a_base + 1]),
        uintBitsToFloat(all_buffers[4].data[a_base + 2])
    );
    float yaw = uintBitsToFloat(all_buffers[4].data[a_base + 3]);
    float pitch = uintBitsToFloat(all_buffers[4].data[a_base + 4]);

    uint seed = sid * 747796405u + pc.iter * 2891336453u + 17u;
    float cost = 0.0;

    vec3 g = vec3(pc.goal_x, pc.goal_y, pc.goal_z);
    vec4 o1 = vec4(pc.obs1_x, pc.obs1_y, pc.obs1_z, pc.obs1_r);
    vec4 o2 = vec4(pc.obs2_x, pc.obs2_y, pc.obs2_z, pc.obs2_r);
    vec4 o3 = vec4(pc.obs3_x, pc.obs3_y, pc.obs3_z, pc.obs3_r);
    vec4 o4 = vec4(pc.obs4_x, pc.obs4_y, pc.obs4_z, pc.obs4_r);
    vec4 o5 = vec4(pc.obs5_x, pc.obs5_y, pc.obs5_z, pc.obs5_r);
    vec4 o6 = vec4(pc.obs6_x, pc.obs6_y, pc.obs6_z, pc.obs6_r);
    vec4 o7 = vec4(pc.obs7_x, pc.obs7_y, pc.obs7_z, pc.obs7_r);
    vec4 o8 = vec4(pc.obs8_x, pc.obs8_y, pc.obs8_z, pc.obs8_r);
    float sid_norm = float(sid) / max(1.0, float(pc.samples - 1u));
    float noise_band = mix(0.35, 1.35, sid_norm);
    if ((sid & 7u) == 0u) noise_band = 0.10; // keep a few near-deterministic elite samples

    const float TURN_GAIN = 1.6;
    for (uint t = 0u; t < pc.horizon; t++) {
        uint cbase = t * 2u;
        float u_yaw = uintBitsToFloat(all_buffers[0].data[cbase + 0]);
        float u_pitch = uintBitsToFloat(all_buffers[0].data[cbase + 1]);

        vec3 to_goal_raw = g - pos;
        float goal_dist = length(to_goal_raw) + 1e-6;
        float desired_yaw = atan(to_goal_raw.z, to_goal_raw.x);
        float desired_pitch = atan(to_goal_raw.y, length(to_goal_raw.xz) + 1e-6);
        float yaw_err = wrap_angle(desired_yaw - yaw);
        float pitch_err = clamp(desired_pitch - pitch, -1.2, 1.2);
        float prior_w = 1.0 - float(t) / max(1.0, float(pc.horizon));
        u_yaw += yaw_err * (1.05 * prior_w);
        u_pitch += pitch_err * (0.92 * prior_w);

        float dg_pre = distance(pos, g);
        float noise_scale = clamp(dg_pre / 5.0, 0.08, 1.0) * noise_band;
        u_yaw += fsigned(seed) * pc.noise_yaw * noise_scale;
        u_pitch += fsigned(seed) * pc.noise_pitch * noise_scale;

        if (t == 0u) {
            uint fbase = sid * 2u;
            all_buffers[8].data[fbase + 0] = floatBitsToUint(u_yaw);
            all_buffers[8].data[fbase + 1] = floatBitsToUint(u_pitch);
        }

        vec3 prev_pos = pos;
        yaw += u_yaw * pc.dt * TURN_GAIN;
        pitch = clamp(pitch + u_pitch * pc.dt * TURN_GAIN, -0.95, 0.95);

        float cp = cos(pitch);
        vec3 dir = vec3(cp * cos(yaw), sin(pitch), cp * sin(yaw));
        pos += dir * (pc.speed * pc.dt);

        uint rbase = (sid * pc.horizon + t) * 4u;
        all_buffers[1].data[rbase + 0] = floatBitsToUint(pos.x);
        all_buffers[1].data[rbase + 1] = floatBitsToUint(pos.y);
        all_buffers[1].data[rbase + 2] = floatBitsToUint(pos.z);
        all_buffers[1].data[rbase + 3] = 0u;

        float dg = goal_dist;
        cost += dg * 3.0;
        cost += (u_yaw * u_yaw + u_pitch * u_pitch) * 0.15;
        vec3 n1 = vec3(1.0, 0.0, 0.0);
        vec3 n2 = vec3(0.0, 0.0, 1.0);
        vec3 n3 = normalize(vec3(1.0, 0.0, 1.0));
        vec3 n4 = normalize(vec3(1.0, 0.0, -1.0));
        vec2 h1 = hoop_cost_reward(pos, dir, o1, n1);
        vec2 h2 = hoop_cost_reward(pos, dir, o2, n2);
        vec2 h3 = hoop_cost_reward(pos, dir, o3, n3);
        vec2 h4 = hoop_cost_reward(pos, dir, o4, n4);
        cost += h1.x * 1.8 + h2.x * 0.65 + h3.x * 0.45 + h4.x * 0.35;
        cost -= h1.y * 8.0 + h2.y * 2.2 + h3.y * 1.2 + h4.y * 0.8;
        cost += plane_patch_pen(pos, o7) + plane_patch_pen(pos, o8);
        if (plane_cross_hit(prev_pos, pos, o7) || plane_cross_hit(prev_pos, pos, o8)) {
            cost += 1e8;
            break;
        }
        float near = max(0.0, pc.goal_r * 2.2 - dg);
        cost -= near * near * 1.8;
        vec3 to_goal = normalize(g - pos + vec3(1e-5));
        float align = dot(dir, to_goal);
        cost += (1.0 - align) * 0.55;

        if (abs(pos.x) > 11.5 || abs(pos.y) > 5.5 || abs(pos.z) > 11.5) {
            cost += 2000.0;
        }
    }

    float terminal = distance(pos, g);
    cost += terminal * terminal * 22.0 + terminal * 20.0;

    all_buffers[2].data[sid] = floatBitsToUint(cost);

    uint ucost = floatBitsToUint(cost);
    uint old = atomicMin(all_buffers[3].data[0], ucost);
    if (ucost < old) {
        all_buffers[3].data[1] = sid;
    }
}
