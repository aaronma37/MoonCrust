#version 450
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 256) in;

layout(set = 0, binding = 0) buffer AllBuffers {
    uint data[];
} all_buffers[];

layout(push_constant) uniform PushConstants {
    uint samples;
    uint horizon;
    uint iter;
    uint pad0;
    float dt;
    float noise_yaw;
    float noise_pitch;
    float speed;
    float goal_x, goal_y, goal_z, goal_r;
    float obs1_x, obs1_y, obs1_z, obs1_r;
    float obs2_x, obs2_y, obs2_z, obs2_r;
    float obs3_x, obs3_y, obs3_z, obs3_r;
    float obs4_x, obs4_y, obs4_z, obs4_r;
} pc;

uint lcg(inout uint s) {
    s = s * 1664525u + 1013904223u;
    return s;
}

float frand(inout uint s) {
    uint v = lcg(s);
    return float(v & 0x00FFFFFFu) / float(0x01000000u);
}

float fsigned(inout uint s) {
    return frand(s) * 2.0 - 1.0;
}

float obs_pen(vec3 p, vec4 o) {
    float d = distance(p, o.xyz);
    float t = max(0.0, o.w - d);
    return t * t * 80.0;
}

void main() {
    uint sid = gl_GlobalInvocationID.x;
    if (sid >= pc.samples) return;

    uint a_base = 0u;
    vec3 pos = vec3(
        uintBitsToFloat(all_buffers[4].data[a_base + 0]),
        uintBitsToFloat(all_buffers[4].data[a_base + 1]),
        uintBitsToFloat(all_buffers[4].data[a_base + 2])
    );
    float yaw = uintBitsToFloat(all_buffers[4].data[a_base + 3]);
    float pitch = uintBitsToFloat(all_buffers[4].data[a_base + 4]);

    uint seed = sid * 747796405u + pc.iter * 2891336453u + 17u;
    float cost = 0.0;

    vec4 o1 = vec4(pc.obs1_x, pc.obs1_y, pc.obs1_z, pc.obs1_r);
    vec4 o2 = vec4(pc.obs2_x, pc.obs2_y, pc.obs2_z, pc.obs2_r);
    vec4 o3 = vec4(pc.obs3_x, pc.obs3_y, pc.obs3_z, pc.obs3_r);
    vec4 o4 = vec4(pc.obs4_x, pc.obs4_y, pc.obs4_z, pc.obs4_r);

    for (uint t = 0u; t < pc.horizon; t++) {
        uint cbase = t * 2u;
        float u_yaw = uintBitsToFloat(all_buffers[0].data[cbase + 0]);
        float u_pitch = uintBitsToFloat(all_buffers[0].data[cbase + 1]);

        u_yaw += fsigned(seed) * pc.noise_yaw;
        u_pitch += fsigned(seed) * pc.noise_pitch;

        if (t == 0u) {
            uint fbase = sid * 2u;
            all_buffers[8].data[fbase + 0] = floatBitsToUint(u_yaw);
            all_buffers[8].data[fbase + 1] = floatBitsToUint(u_pitch);
        }

        yaw += u_yaw * pc.dt;
        pitch = clamp(pitch + u_pitch * pc.dt, -0.95, 0.95);

        float cp = cos(pitch);
        vec3 dir = vec3(cp * cos(yaw), sin(pitch), cp * sin(yaw));
        pos += dir * (pc.speed * pc.dt);

        uint rbase = (sid * pc.horizon + t) * 4u;
        all_buffers[1].data[rbase + 0] = floatBitsToUint(pos.x);
        all_buffers[1].data[rbase + 1] = floatBitsToUint(pos.y);
        all_buffers[1].data[rbase + 2] = floatBitsToUint(pos.z);
        all_buffers[1].data[rbase + 3] = 0u;

        vec3 g = vec3(pc.goal_x, pc.goal_y, pc.goal_z);
        float dg = distance(pos, g);
        cost += dg * 1.1;
        cost += (u_yaw * u_yaw + u_pitch * u_pitch) * 0.18;
        cost += obs_pen(pos, o1) + obs_pen(pos, o2) + obs_pen(pos, o3) + obs_pen(pos, o4);

        if (abs(pos.x) > 11.5 || abs(pos.y) > 5.5 || abs(pos.z) > 11.5) {
            cost += 2000.0;
        }
    }

    float terminal = distance(pos, vec3(pc.goal_x, pc.goal_y, pc.goal_z));
    cost += terminal * terminal * 3.5;

    all_buffers[2].data[sid] = floatBitsToUint(cost);

    uint ucost = floatBitsToUint(cost);
    uint old = atomicMin(all_buffers[3].data[0], ucost);
    if (ucost < old) {
        all_buffers[3].data[1] = sid;
    }
}
