#version 450
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 256) in;

layout(set = 0, binding = 0) buffer AllBuffers {
    uint data[];
} all_buffers[];

layout(push_constant) uniform PushConstants {
    uint node_count;
    uint edge_count;
    uint iter;
    uint pad;
    float obs_x, obs_y, obs_z, obs_r;
    float rew1_x, rew1_y, rew1_z, rew1_r;
    float rew2_x, rew2_y, rew2_z, rew2_r;
    float rew3_x, rew3_y, rew3_z, rew3_r;
    float rew4_x, rew4_y, rew4_z, rew4_r;
} pc;

float reward_contrib(vec3 p, vec3 center, float radius) {
    float d = distance(p, center);
    float t = clamp(1.0 - d / max(radius, 0.001), 0.0, 1.0);
    return t * 9.0;
}

void main() {
    uint edge_idx = gl_GlobalInvocationID.x;
    vec3 obs_pos = vec3(pc.obs_x, pc.obs_y, pc.obs_z);
    vec3 rew1_pos = vec3(pc.rew1_x, pc.rew1_y, pc.rew1_z);
    vec3 rew2_pos = vec3(pc.rew2_x, pc.rew2_y, pc.rew2_z);
    vec3 rew3_pos = vec3(pc.rew3_x, pc.rew3_y, pc.rew3_z);
    vec3 rew4_pos = vec3(pc.rew4_x, pc.rew4_y, pc.rew4_z);

    if (edge_idx < pc.edge_count) {
        uint e_base = edge_idx * 4;
        uint nodeA = all_buffers[1].data[e_base + 0];
        uint nodeB = all_buffers[1].data[e_base + 1];
        float e_dist = uintBitsToFloat(all_buffers[1].data[e_base + 2]);
        float e_cost = uintBitsToFloat(all_buffers[1].data[e_base + 3]);

        uint nA_base = nodeA * 8;
        uint nB_base = nodeB * 8;
        vec3 pA = vec3(uintBitsToFloat(all_buffers[0].data[nA_base + 0]), uintBitsToFloat(all_buffers[0].data[nA_base + 1]), uintBitsToFloat(all_buffers[0].data[nA_base + 2]));
        vec3 pB = vec3(uintBitsToFloat(all_buffers[0].data[nB_base + 0]), uintBitsToFloat(all_buffers[0].data[nB_base + 1]), uintBitsToFloat(all_buffers[0].data[nB_base + 2]));
        vec3 mid = (pA + pB) * 0.5;

        if (distance(mid, obs_pos) < pc.obs_r) {
            return;
        }

        float reward_gain =
            reward_contrib(mid, rew1_pos, pc.rew1_r) +
            reward_contrib(mid, rew2_pos, pc.rew2_r) +
            reward_contrib(mid, rew3_pos, pc.rew3_r) +
            reward_contrib(mid, rew4_pos, pc.rew4_r);

        for (int i = 0; i < 8; i++) {
            uint solA_base = (nodeA * 8 + i) * 5;
            float solA_dist = uintBitsToFloat(all_buffers[2].data[solA_base + 0]);
            float solA_cost = uintBitsToFloat(all_buffers[2].data[solA_base + 1]);
            float solA_reward = uintBitsToFloat(all_buffers[2].data[solA_base + 2]);

            if (solA_dist >= 1e8) {
                continue;
            }

            float new_dist = solA_dist + e_dist;
            float new_cost = solA_cost + e_cost;
            float new_reward = solA_reward + reward_gain;

            bool dominated = false;
            int empty_slot = -1;
            int replace_slot = -1;
            int worst_slot = -1;
            float worst_score = -1e30;

            for (int j = 0; j < 8; j++) {
                uint solB_base = (nodeB * 8 + j) * 5;
                float solB_dist = uintBitsToFloat(all_buffers[2].data[solB_base + 0]);
                float solB_cost = uintBitsToFloat(all_buffers[2].data[solB_base + 1]);
                float solB_reward = uintBitsToFloat(all_buffers[2].data[solB_base + 2]);

                if (solB_dist >= 1e8) {
                    if (empty_slot == -1) {
                        empty_slot = j;
                    }
                    continue;
                }

                if (solB_dist <= new_dist && solB_cost <= new_cost && solB_reward >= new_reward) {
                    dominated = true;
                    break;
                }

                float old_score = solB_dist + solB_cost - (solB_reward * 0.8);
                if (old_score > worst_score) {
                    worst_score = old_score;
                    worst_slot = j;
                }

                bool new_dominates_old = (new_dist <= solB_dist && new_cost <= solB_cost && new_reward >= solB_reward) &&
                                         (new_dist < solB_dist || new_cost < solB_cost || new_reward > solB_reward);
                if (new_dominates_old && replace_slot == -1) {
                    replace_slot = j;
                }
            }

            float new_score = new_dist + new_cost - (new_reward * 0.8);
            bool can_replace_worst = (empty_slot == -1 && replace_slot == -1 && worst_slot != -1 && new_score < worst_score);

            if (!dominated && (empty_slot != -1 || replace_slot != -1 || can_replace_worst)) {
                int slot = empty_slot != -1 ? empty_slot : (replace_slot != -1 ? replace_slot : worst_slot);
                uint target_base = (nodeB * 8 + uint(slot)) * 5;
                all_buffers[2].data[target_base + 0] = floatBitsToUint(new_dist);
                all_buffers[2].data[target_base + 1] = floatBitsToUint(new_cost);
                all_buffers[2].data[target_base + 2] = floatBitsToUint(new_reward);
                all_buffers[2].data[target_base + 3] = nodeA;
                all_buffers[2].data[target_base + 4] = i;

                all_buffers[0].data[nodeB * 8 + 4] = floatBitsToUint(0.2);
                all_buffers[0].data[nodeB * 8 + 5] = floatBitsToUint(0.5);
                all_buffers[0].data[nodeB * 8 + 6] = floatBitsToUint(1.0);
            }
        }
    }

    if (edge_idx == 0) {
        float mx = uintBitsToFloat(all_buffers[3].data[0]);
        float my = uintBitsToFloat(all_buffers[3].data[1]);

        if (mx < 1.5) {
            float min_d = 1e9;
            uint best_node = 0xFFFFFFFF;
            uint best_sol = 0;

            for (uint n = 0; n < pc.node_count; n++) {
                for (int s = 0; s < 8; s++) {
                    uint base = (n * 8 + s) * 5;
                    float d = uintBitsToFloat(all_buffers[2].data[base + 0]);
                    float c = uintBitsToFloat(all_buffers[2].data[base + 1]);
                    if (d > 1e8) {
                        continue;
                    }

                    float px = (d / 40.0) - 0.9;
                    float py = (c / 40.0) - 0.9;
                    float dd = (px - mx) * (px - mx) + (py - (-my)) * (py - (-my));
                    if (dd < min_d) {
                        min_d = dd;
                        best_node = n;
                        best_sol = s;
                    }
                }
            }

            all_buffers[3].data[2] = best_node;
            all_buffers[3].data[3] = best_sol;
        } else {
            all_buffers[3].data[2] = 0xFFFFFFFF;
        }
    }
}
