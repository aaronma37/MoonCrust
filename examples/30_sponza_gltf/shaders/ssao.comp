#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 1, binding = 1, rgba16f) uniform readonly image2D g_normal;
layout(set = 1, binding = 3, rgba16f) uniform readonly image2D g_worldpos;
layout(set = 1, binding = 6, r8) uniform image2D img_ssao;
layout(set = 1, binding = 8) uniform sampler2D tex_noise;

layout(set = 1, binding = 9) readonly buffer SSAOKernel {
    vec4 samples[64];
} kernel;

layout(push_constant) uniform PushConstants {
    mat4 view_proj;
    vec4 cam_pos;
    vec4 light_pos;
    vec4 base_color;
    mat4 light_space;
    float time;
    uint albedo_idx;
    uint normal_idx;
    uint mra_idx;
} pc;

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(img_ssao);
    if (pos.x >= size.x || pos.y >= size.y) return;

    ivec2 fullPos = pos * 2;
    vec3 worldPos = imageLoad(g_worldpos, fullPos).xyz;
    vec3 normal = imageLoad(g_normal, fullPos).xyz * 2.0 - 1.0;
    
    vec3 randomVec = texture(tex_noise, vec2(pos) / 4.0).xyz;
    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
    vec3 bitangent = cross(normal, tangent);
    mat3 TBN = mat3(tangent, bitangent, normal);

    float occlusion = 0.0;
    float radius = 0.5;
    float bias = 0.025;

    for(int i = 0; i < 64; ++i) {
        vec3 samplePos = TBN * kernel.samples[i].xyz;
        samplePos = worldPos + samplePos * radius;
        
        vec4 offset = pc.view_proj * vec4(samplePos, 1.0);
        offset.xyz /= offset.w;
        offset.xy = offset.xy * 0.5 + 0.5;
        
        ivec2 sampleCoords = ivec2(offset.xy * vec2(imageSize(g_worldpos)));
        float sampleDepth = imageLoad(g_worldpos, sampleCoords).z;
        
        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(worldPos.z - sampleDepth));
        occlusion += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0) * rangeCheck;
    }

    occlusion = 1.0 - (occlusion / 64.0);
    imageStore(img_ssao, pos, vec4(occlusion, 0.0, 0.0, 1.0));
}
