#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 1, binding = 3, rgba16f) uniform readonly image2D g_worldpos;
layout(set = 1, binding = 5) uniform sampler2D shadow_map;
layout(set = 1, binding = 12, rgba16f) uniform image2D img_volumetric;

layout(push_constant) uniform PushConstants {
    mat4 view_proj;
    vec4 cam_pos;
    vec4 light_pos;
    vec4 base_color;
    mat4 light_space;
    float time;
    uint albedo_idx;
    uint normal_idx;
    uint mra_idx;
} pc;

float InterleavedGradientNoise(vec2 uv) {
    return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))));
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(img_volumetric);
    if (pos.x >= size.x || pos.y >= size.y) return;

    vec3 worldPos = imageLoad(g_worldpos, pos * 2).xyz;
    vec3 startPos = pc.cam_pos.xyz;
    vec3 rayDir = worldPos - startPos;
    float totalDist = length(rayDir);
    rayDir /= totalDist;

    float rayLength = min(totalDist, 60.0);
    const int steps = 24; 
    float stepSize = rayLength / float(steps);
    
    float dither = InterleavedGradientNoise(vec2(pos));
    vec3 currentPos = startPos + rayDir * stepSize * dither;

    vec3 accumulation = vec3(0.0);
    for (int i = 0; i < steps; ++i) {
        vec4 fragPosLightSpace = pc.light_space * vec4(currentPos, 1.0);
        vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
        projCoords.xy = projCoords.xy * 0.5 + 0.5;

        if (projCoords.z <= 1.0 && projCoords.x >= 0.0 && projCoords.x <= 1.0 && projCoords.y >= 0.0 && projCoords.y <= 1.0) {
            float shadowDepth = texture(shadow_map, projCoords.xy).r;
            if (shadowDepth > projCoords.z - 0.02) { 
                float dist = length(currentPos - startPos);
                float atten = exp(-dist * 0.04); 
                accumulation += vec3(1.0, 0.9, 0.7) * atten;
            }
        }
        currentPos += rayDir * stepSize;
    }

    vec3 result = (accumulation / float(steps)) * 0.08; 
    imageStore(img_volumetric, pos, vec4(result, 1.0));
}
