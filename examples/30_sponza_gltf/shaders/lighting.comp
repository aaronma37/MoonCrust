#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 1, binding = 0, rgba8) uniform readonly image2D g_albedo;
layout(set = 1, binding = 1, rgba16f) uniform readonly image2D g_normal;
layout(set = 1, binding = 2, rgba8) uniform readonly image2D g_mra;
layout(set = 1, binding = 3, rgba16f) uniform readonly image2D g_worldpos;
layout(set = 1, binding = 4, rgba16f) uniform image2D hdr_color;
layout(set = 1, binding = 5) uniform sampler2D shadow_map;
layout(set = 1, binding = 13) uniform sampler2D tex_ssao; 

layout(push_constant) uniform PushConstants {
    mat4 view_proj;
    vec4 cam_pos;
    vec4 light_pos;
    vec4 base_color;
    mat4 light_space;
    float time;
    uint albedo_idx;
    uint normal_idx;
    uint mra_idx;
} pc;

const float PI = 3.14159265359;

float ShadowCalculation(vec3 worldPos, vec3 normal, vec3 lightPos) {
    vec4 fragPosLightSpace = pc.light_space * vec4(worldPos, 1.0);
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords.xy = projCoords.xy * 0.5 + 0.5;
    if (projCoords.z > 1.0) return 0.0;
    float currentDepth = projCoords.z;
    vec3 lightDir = normalize(lightPos - worldPos);
    float bias = max(0.005 * (1.0 - dot(normal, lightDir)), 0.0005);
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadow_map, 0);
    for(int x = -1; x <= 1; ++x) {
        for(int y = -1; y <= 1; ++y) {
            float pcfDepth = texture(shadow_map, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;        
        }    
    }
    return shadow / 9.0;
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(hdr_color);
    if (pos.x >= size.x || pos.y >= size.y) return;
    
    vec3 albedo = imageLoad(g_albedo, pos).rgb;
    vec3 N = imageLoad(g_normal, pos).rgb * 2.0 - 1.0;
    vec3 worldPos = imageLoad(g_worldpos, pos).rgb;
    
    vec3 lightPos = pc.light_pos.xyz;
    vec3 lightColor = vec3(10.0, 9.0, 8.0);

    vec3 L = normalize(lightPos - worldPos);
    float NdotL = max(dot(N, L), 0.0);
    float shadow = ShadowCalculation(worldPos, N, lightPos);

    vec3 direct = albedo * lightColor * NdotL * (1.0 - shadow);
    
    vec2 uv = (vec2(pos) + 0.5) / vec2(size);
    float ssao = texture(tex_ssao, uv).r;
    vec3 ambient = vec3(0.03) * albedo * ssao;

    imageStore(hdr_color, pos, vec4(ambient + direct, 1.0));
}
