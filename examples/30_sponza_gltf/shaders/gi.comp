#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 1, binding = 1) uniform sampler2D g_depth;
layout(set = 1, binding = 5) uniform sampler2D shadow_map;
layout(set = 1, binding = 15) uniform sampler2D rsm_flux;
layout(set = 1, binding = 16) uniform sampler2D rsm_normal;
layout(set = 1, binding = 17, rgba16f) uniform image2D img_gi;

layout(push_constant) uniform PushConstants {
    mat4 view_proj;
    mat4 inv_view_proj;
    vec4 cam_pos;
    vec4 light_pos;
    vec4 base_color;
    mat4 light_space;
    float time;
} pc;

vec3 WorldPosFromDepth(vec2 uv, float depth) {
    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 worldPos = pc.inv_view_proj * clipPos;
    return worldPos.xyz / worldPos.w;
}

float InterleavedGradientNoise(vec2 uv) {
    return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))));
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(img_gi);
    if (pos.x >= size.x || pos.y >= size.y) return;

    vec2 uv = (vec2(pos) + 0.5) / vec2(size);
    float depth = texture(g_depth, uv).r;
    if (depth >= 1.0) {
        imageStore(img_gi, pos, vec4(0.0));
        return;
    }

    vec3 worldPos = WorldPosFromDepth(uv, depth);
    
    // Normal reconstruction from depth
    float d = 0.001;
    vec3 v1 = WorldPosFromDepth(uv + vec2(d, 0), texture(g_depth, uv + vec2(d, 0)).r);
    vec3 v2 = WorldPosFromDepth(uv + vec2(0, d), texture(g_depth, uv + vec2(0, d)).r);
    vec3 N = normalize(cross(v1 - worldPos, v2 - worldPos));
    
    vec4 fragPosLightSpace = pc.light_space * vec4(worldPos, 1.0);
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords.xy = projCoords.xy * 0.5 + 0.5;
    
    vec3 indirect = vec3(0.0);
    const int samples = 16;
    float rsm_radius = 0.3;
    
    float noise = InterleavedGradientNoise(vec2(pos));
    float angle_offset = noise * 6.28318;

    for(int i = 0; i < samples; ++i) {
        float r = sqrt(float(i+0.5)/float(samples));
        float theta = float(i) * 2.39996 + angle_offset;
        vec2 offset = vec2(cos(theta), sin(theta)) * r * rsm_radius;
        vec2 sampleUV = projCoords.xy + offset;

        if (sampleUV.x >= 0.0 && sampleUV.x <= 1.0 && sampleUV.y >= 0.0 && sampleUV.y <= 1.0) {
            vec3 vplFlux = texture(rsm_flux, sampleUV).rgb;
            vec3 vplNormal = texture(rsm_normal, sampleUV).rgb * 2.0 - 1.0;
            
            float distSq = dot(offset, offset) * 50.0 + 0.001;
            float weight = max(0.0, dot(vplNormal, normalize(vec3(offset, 0.2)))); 
            weight *= max(0.0, dot(N, -normalize(vec3(offset, 0.2))));
            
            indirect += vplFlux * weight / distSq;
        }
    }

    imageStore(img_gi, pos, vec4(indirect / float(samples) * 10.0, 1.0));
}
