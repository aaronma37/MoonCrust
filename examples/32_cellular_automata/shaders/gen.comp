#version 450
#extension GL_EXT_nonuniform_qualifier : enable
layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants {
    uint world_w, world_h; float time; uint frame_count;
    float mouse_x, mouse_y; uint brush_material, brush_size;
    uint in_buf_idx, out_buf_idx; float cam_x, cam_y;
    uint screen_w, screen_h; uint light_img_idx, out_img_idx;
} pc;

struct Pixel { uint data0; uint data1; };
layout(set = 0, binding = 0) buffer WorldBuffers { Pixel cells[]; } all_buffers[];

uint pack_data0(uint id, uint temp, int vx, int vy) { return (id << 24) | (temp << 16) | ((uint(vx) & 0xFFu) << 8) | (uint(vy) & 0xFFu); }
uint pack_data1(uint density, uint life, uint trigger, uint payload, uint flags) { return (density << 24) | (life << 16) | (trigger << 12) | (payload << 4) | flags; }

float hash(vec2 p) { p = fract(p * vec2(123.34, 456.21)); p += dot(p, p + 45.32); return fract(p.x * p.y); }
float noise(vec2 p) {
    vec2 i = floor(p); vec2 f = fract(p);
    float a = hash(i); float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}
float fbm(vec2 p) { float v = 0.; float a = 0.5; for(int i=0; i<5; i++) { v+=a*noise(p); p*=2.; a*=.5; } return v; }

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    if (pos.x >= pc.world_w || pos.y >= pc.world_h) return;

    uint idx = pos.y * pc.world_w + pos.x;
    float n = fbm(vec2(pos) * 0.01 + pc.time);
    float height_norm = float(pos.y) / float(pc.world_h);
    
    uint id = 0; uint density = 0; uint flags = 0; uint life = 0;
    float surface_y = (0.25 + noise(vec2(float(pos.x) * 0.005, pc.time)) * 0.1) * float(pc.world_h);
    
    if (float(pos.y) > surface_y) {
        id = 6; density = 255; flags = 3; 
        if (n < 0.4) { id = 0; flags = 2; } 
        if (n > 0.6) { id = 1; density = 200; flags = 3; } 
    }

    // ANCIENT TREES (Energy = 120 << 4 = 1920 potential segments)
    if (abs(float(pos.y) - surface_y) < 3.0 && hash(vec2(pos.x, pc.time)) > 0.99) {
        id = 12; 
        life = (120u << 4) | 5u; 
        density = 150; flags = 1; 
    }

    // MACRO CABINS
    int cabin_spacing = 800;
    int base_x = (pos.x / cabin_spacing) * cabin_spacing + cabin_spacing / 2;
    float cabin_surface_y = (0.25 + noise(vec2(float(base_x) * 0.005, pc.time)) * 0.1) * float(pc.world_h);
    ivec2 rel = pos - ivec2(base_x, int(cabin_surface_y));
    if (rel.x >= -50 && rel.x <= 50 && rel.y >= -80 && rel.y <= 0) {
        id = 6; density = 255; flags = 3; 
        if ((rel.x % 10 == 0) || (rel.y % 6 == 0)) { id = 0; flags = 2; }
        if (rel.y < -60) { id = 10; flags = 3; if (rel.x % 4 == 0) { id = 0; flags = 2; } }
        if (abs(rel.x) < 15 && rel.y > -40) { id = 0; flags = 2; }
        if (abs(rel.x) > 25 && abs(rel.x) < 40 && rel.y > -35 && rel.y < -20) { id = 0; flags = 2; }
    }
    
    // PLAYER CHARACTER
    if (rel.x == -70 && rel.y >= -48 && rel.y <= 0) {
        id = 15; density = 255; flags = 1; 
        if (rel.y < -40) { if(abs(rel.x+70) > 4) id=0; }
        else if (rel.y < -15) { if(abs(rel.x+70) > 8) id=0; }
        else { if(abs(rel.x+70) > 4 && abs(rel.x+70) < 8) id=15; else id=0; }
    }

    if (pos.y > int(pc.world_h) - 10) { id = 6; density = 255; flags = 3; }

    Pixel p;
    p.data0 = pack_data0(id, 128, 0, 0);
    p.data1 = pack_data1(density, life, 0, 0, flags);

    all_buffers[0].cells[idx] = p;
    all_buffers[1].cells[idx] = p;
}
