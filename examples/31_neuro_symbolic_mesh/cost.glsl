// Neuro-Symbolic Dragon Cost Function (Corrected Orientation)
// Generated by Gemini 2.5 Flash

float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
    vec3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h) - r;
}

float sdRoundBox(vec3 p, vec3 b, float r) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;
}

float smin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * (1.0 / 4.0);
}

void pRotZ(inout vec3 p, float a) {
    float s = sin(a), c = cos(a);
    p.xy = mat2(c, -s, s, c) * p.xy;
}

void pRotY(inout vec3 p, float a) {
    float s = sin(a), c = cos(a);
    p.xz = mat2(c, -s, s, c) * p.xz;
}

float compute_shape_cost(vec3 p, float time) {
    // 1. BODY
    float d = sdCapsule(p, vec3(0, 1.5, -1.0), vec3(0, 1.5, 1.5), 0.8);
    
    // 2. NECK & HEAD
    float neck = sdCapsule(p, vec3(0, 1.5, 1.5), vec3(0, 3.0, 3.0), 0.4);
    float head = sdCapsule(p, vec3(0, 3.0, 3.0), vec3(0, 3.2, 4.0), 0.5);
    d = smin(d, neck, 0.6);
    d = smin(d, head, 0.4);
    
    // 3. TAIL
    float tail = sdCapsule(p, vec3(0, 1.5, -1.0), vec3(0, 0.5, -4.5), 0.3);
    d = smin(d, tail, 0.6);
    
    // 4. LEGS
    float l1 = sdCapsule(p, vec3(-0.8, 1.5, 1.0), vec3(-1.0, 0.0, 1.2), 0.3);
    float l2 = sdCapsule(p, vec3( 0.8, 1.5, 1.0), vec3( 1.0, 0.0, 1.2), 0.3);
    float l3 = sdCapsule(p, vec3(-0.8, 1.2, -0.5), vec3(-1.0, 0.0, -0.7), 0.3);
    float l4 = sdCapsule(p, vec3( 0.8, 1.2, -0.5), vec3( 1.0, 0.0, -0.7), 0.3);
    d = smin(d, l1, 0.3); d = smin(d, l2, 0.3); d = smin(d, l3, 0.3); d = smin(d, l4, 0.3);
    
    // 5. CORRECTED WINGS
    float flap = sin(time * 3.5) * 0.5;
    
    // Left Wing
    vec3 pl = p - vec3(-0.8, 2.0, 0.0); // Pivot at shoulder
    pRotY(pl, -0.4); // Sweep back
    pRotZ(pl, 0.5 + flap); // Flap
    float wing_l = sdRoundBox(pl - vec3(-2.0, 0, 0), vec3(2.0, 0.05, 1.2), 0.1);
    
    // Right Wing
    vec3 pr = p - vec3(0.8, 2.0, 0.0);
    pRotY(pr, 0.4);
    pRotZ(pr, -0.5 - flap);
    float wing_r = sdRoundBox(pr - vec3(2.0, 0, 0), vec3(2.0, 0.05, 1.2), 0.1);
    
    d = smin(d, wing_l, 0.5);
    d = smin(d, wing_r, 0.5);
    
    // 6. SPINES
    float spines = sin(p.z * 4.0) * 0.2 * step(1.5, p.y);
    d -= spines * 0.08;
    
    return d;
}
